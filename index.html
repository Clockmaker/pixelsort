<!DOCTYPE html>
<meta charset="UTF-8"> 
<head>
<title>Pixel Sort</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0 user-scalable=0, shrink-to-fit=no">
<style>
html,body{min-height:100%;margin:0;background-color:#EFEFEF;font-family:sans-serif;font-size:12px;}
#wrap{margin:1em auto;width:60%;}
#sandbox{margin-top:2em;}
canvas{display:block;}
.sort{position:relative;float:left;}
.tag {position:absolute;display:inline; left:4px;top:8px;background-color:rgba(0,0,0,.7);color:#FFF;padding:4px}
/*Mobile*/
@media(max-width: 960px){html{font-size:12px;}#wrap{margin:1em 1%;width:98%;}
</style>
</head><body>
<div id="wrap">
 <select id="tile_color">
 </select>
 <select id="tile_size">
  <option value='2'> 2 px</option>
  <option value='4'> 4 px</option>
  <option value='8'> 8 px</option>
  <option value='16'>16 px</option>
 </select>
 <button onclick="p.play()">Play/Stop</button>
 <button onclick="p.reset()">Reset</button>
<br/>
 <details>
 <summary>Sorting Algorithms</summary>
    <div id="algorithms"></div>
 </details>

<div id="sandbox"></div>
</div>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="./sort.js"></script>
<script>
var 
canvas_width = 400, canvas_height=400,
default_tile_size = 8,
default_tile_row = canvas_height/default_tile_size ,
default_tile_col = canvas_width/default_tile_size,
tile = {col:default_tile_col, row:default_tile_row, size:default_tile_size};
/*************************************************************/
var pixelcanvas = function(dom, tile = {col:100, row:1, size:10}, canvas_class=null) {
    this.canvas = document.createElement("canvas");
    this.canvas.width = tile.col*tile.size;
    this.canvas.height = tile.row*tile.size;
    dom.appendChild(this.canvas);
    if(canvas_class) this.canvas.attr("class", canvas_class);
    this.context = this.canvas.getContext("2d");

    this.row = tile.row;
    this.tile = {col:tile.col, row:tile.row, size:tile.size};
    

    this.play = false;
};

pixelcanvas.prototype = {
    animate: function(unsorted_array, swap){
        this.array = unsorted_array.slice(0);
        this.frame = swap.slice(0);
        //
        let max = 0;
        this.frame.forEach((r)=>{if(max < r.length) max=r.length;})
        
        this.duration = max;
        this.frame_length = max;
        
        this.reset();
        //return this.frame_lenght;
    },
    start: function(){
        this.play = true;
        requestAnimationFrame(this.draw.bind(this));
    },
    stop: function(){
        this.play = false;
    },
    reset: function(){
        for(var row = 0; row < this.row; row++){
            this.array[row].forEach((d,i)=>{this.draw_tile(i, row, d);});
        }
        this.step = 0;
    },
    draw_tile: function(i, j, fill){
        this.context.beginPath();
        this.context.rect(i*this.tile.size,j*this.tile.size,this.tile.size,this.tile.size);
        this.context.fillStyle= color(fill);
        this.context.fill();
        this.context.closePath();
    },
    draw: function(){
        var s;
        for(var row = 0; row < this.row; row++){
            if(this.step < this.frame[row].length){
                s = this.frame[row][this.step];
                this.draw_tile(s[0], row, s[2]);
                this.draw_tile(s[1], row, s[3]);
            }
        }
        this.step++
        if(this.step > this.duration){
            this.reset()
        }
        if(this.play) requestAnimationFrame(this.draw.bind(this));
    }

};

function pixelsort(array, compare_fn){
    this.array = array;
    this.compare = compare_fn;
    this.fn_list = {};
    this.fn_ptr = {};
    this.fn_dom = {};
    this.run = true;
    this.tile = {col:100, row:1, size:1};
    this.dom = document.body;

    this.tileset = function(tile){
        this.tile = tile;
    };
    this.attach = function(dom){
        this.dom = dom;
    };
    this.setup = function(array, compare_fn){
        this.array = array;
        this.compare = compare_fn;
    };
    //TODO: create multiple istances for the same algorithm
    this.create = function(algo){
            var key = (typeof algo === 'function') ? algo.name
                                                   : algo;
            //careful: global row and swap_history
            swap_history = [];
            for(row=0; row < this.tile.row; row++){
                swap_history[row] = [];
                algo(this.array[row].slice(0), this.compare);
            }
            var dom = this.fn_dom[key];
            if(!dom){
                dom = this.dom;
                this.fn_dom[key] = dom;
            }
            this.fn_list[key] = new pixelcanvas(dom, this.tile);
            this.fn_list[key].animate(this.array, swap_history);
            this.fn_ptr[key] = algo;//window[key];
    };
    this.clear = function(){
        for(var key in this.fn_list){
            this.destroy(key);
        }
    };
    this.reset = function(){
        for(var key in this.fn_list){
            this.fn_list[key].reset();
        }
    };

    this.rebuild = function(){
        for(var key in this.fn_list){
            this.remove(key);
            this.create(this.fn_ptr[key]);
        }
    }
    this.remove = function(algo){
        var name = (typeof algo === 'function') ? algo.name
                                                : algo;
        this.fn_list[name].canvas.remove();
    };
    this.destroy = function(algo){
        this.remove(algo);
        delete this.fn_list[name];
    };
    this.startAll = function(){
        for(var key in this.fn_list){
            this.fn_list[key].start();
        }
    };
    this.stopAll = function(){
        for(var key in this.fn_list){
            this.fn_list[key].stop();
        }
    };
    this.play = function(){
        this.run = !this.run;
        return (this.run)?this.startAll():this.stopAll();
    };
}
/*************************************************************/

var color = d3.scaleSequential(d3.interpolateViridis).domain([0,tile.col]);

var cmp = (a,b)=>{return a>b};


/**/
if(window.location.hash){
tile.size = Number(window.location.hash.substring(1));
}


var colormap = ["Viridis", "Rainbow", "Greys"];
var colorselect = document.getElementById("tile_color");
colormap.forEach((map)=>{colorselect.innerHTML +='<option value="'+map+'">'+map+'</option>';});
colorselect.addEventListener("change", function(e){
    color = d3.scaleSequential(d3["interpolate"+e.target.value]).domain([0,tile.col]);
    p.rebuild();
    p.startAll();
});


document.getElementById("tile_size").addEventListener("change",function(e){
    tile.size = Number(e.target.value);
    tile.col = canvas_width/tile.size;
    tile.row = canvas_height/tile.size;
color = d3.scaleSequential(d3["interpolate"+colorselect.value]).domain([0,tile.col])
p.setup(grid(tile.col, tile.row), cmp);
//p.tileset('#sandbox', tile);
//p.add(insertionsort, insertionsort_binary, quicksort, quicksort_dualpivot);
p.rebuild();
p.startAll();
});

var grid = function(col, row){
    var tiles = [];
    for(var r=0; r < row; r++){
        tiles[r] = d3.range(col+1);
        shuffle(tiles[r]);
    }
    return tiles;
};
//Fisher--Yates' shuffle
//nicely explained and visualized here, https://bost.ocks.org/mike/shuffle/
function shuffle(array){
    var m = array.length, rand;
    while(--m){
            rand = ~~(Math.random()*m);
            [array[m], array[rand]] = [array[rand], array[m]];
    }
}


var p;
p = new pixelsort(grid(default_tile_col, default_tile_row), cmp);

p.tileset(tile);
var d = document.createElement("div");
d.className = "sort" 
document.getElementById("sandbox").appendChild(d);
p.attach(d);
p.create(insertionsort);
var tag = document.createElement("div");
tag.className = "tag";
tag.innerHTML = "insertionsort"
d.appendChild(tag);

d = document.createElement("div");
d.className = "sort" 
document.getElementById("sandbox").appendChild(d);
p.attach(d);
p.create(insertionsort_binary);
var tag = document.createElement("div");
tag.className = "tag";
tag.innerHTML = "insertionsort"
d.appendChild(tag);


p.startAll();

var chk = document.getElementById("algorithms");
var algorithms = [insertionsort, insertionsort_binary, lampsort, quicksort, quicksort_dualpivot];
algorithms.forEach((fn)=>{
let n = fn.name;
chk.innerHTML += '<input type="checkbox" id="'+n+'" name="'+n+'" value="'+n+'" /><label for="'+n+'">'+n+'</label>';
});
</script>
</body>