<!DOCTYPE html>
<meta charset="UTF-8"> 
<head>
<title>Pixel Sort</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0 user-scalable=0, shrink-to-fit=no">
<style>
html,body{min-height:100%;margin:0;background-color:#EFEFEF;font-family:sans-serif;font-size:12px;}
#wrap{margin:1em auto;width:60%;}
canvas{display:block;width:100%;}

/*Mobile*/
@media(max-width: 960px){html{font-size:12px;}#wrap{margin:1em 1%;width:98%;}}
</style>
</head><body>
<div id="wrap">
 <select id="tile_size">
  <option value='2'> 2 px</option>
  <option value='4' selected> 4 px</option>
  <option value='8'> 8 px</option>
  <option value='16'>16 px</option>
  <option value='32'>32 px</option>
 </select> 
 <button onclick="p.play()">Play/Stop</button>
 <button onclick="p.reset()">Reset</button>
<br/>
 <details>
 <summary>Sorting Algorithms</summary>
    <div id="algorithms"></div>
 </details>

<div id="sandbox"></div>
</div>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script>

var canvas_width = 880, canvas_height=80;

var 
default_tile_size = 4,
default_tile_row = canvas_height/default_tile_size ,
default_tile_col = canvas_width/default_tile_size,
tile = {col:default_tile_col, row:default_tile_row, size:default_tile_size};

var color = d3.scaleSequential(d3.interpolateViridis).domain([0,default_tile_col]);


var cmp = (a,b)=>{return a>b};


/**/

document.getElementById("tile_size").addEventListener("change",function(e){
    tile.size = Number(e.target.value);
    tile.col = canvas_width/tile.size;
    tile.row = canvas_height/tile.size;
color = d3.scaleSequential(d3.interpolateViridis).domain([0,tile.col])
p.setup(grid(tile.col, tile.row), cmp);
//p.tileset('#sandbox', tile);
//p.add(insertionsort, insertionsort_binary, quicksort, quicksort_dualpivot);
p.rebuild();
p.startAll();
});


var pixelcanvas = function(node_id, unsorted_array, swap, tile = {col:100, row:1, size:10}) {
    this.canvas = d3.select(node_id)
            .append("canvas")
            .attr("width", tile.col*tile.size)
            .attr("height", tile.row*tile.size);
    this.context = this.canvas.node().getContext("2d");

    this.array = unsorted_array.slice(0);
    this.frame = swap.slice(0);

    this.row = tile.row;
    this.tile = {col:tile.col, row:tile.row, size:tile.size};

    this.play = true;
};

pixelcanvas.prototype = {
    start: function(){
        //this.reset();
        this.play = true;
        requestAnimationFrame(this.draw.bind(this));
    },
    stop: function(){
        this.play = false;
    },
    reset : function(){
        for(var row = 0; row < this.row; row++){
            this.array[row].forEach((d,i)=>{this.draw_tile(i, row, d);});
        }
        this.step = 0;
    },
    draw_tile: function(i, j, fill){
        this.context.beginPath();
        this.context.rect(i*this.tile.size,j*this.tile.size,this.tile.size,this.tile.size);
        this.context.fillStyle= color(fill);
        this.context.fill();
        this.context.closePath();
    },
    draw: function(){
        var end = this.row, s;
        for(var row = 0; row < this.row; row++){
            if(this.step < this.frame[row].length){
                s = this.frame[row][this.step];
                this.draw_tile(s[0], row, s[2]);
                this.draw_tile(s[1], row, s[3]);
            }else{
                end--;

            }
        }
        this.step++
        if(end == 0){
            this.reset()
        }
        if(this.play) requestAnimationFrame(this.draw.bind(this));
    }

};


var grid = function(col, row){
    var tiles = [];
    for(var r=0; r < row; r++){
        tiles[r] = d3.range(col+1);
        shuffle(tiles[r]);
    }
    return tiles;
};

// ugly globals
var swap_history = [], row = 0;






function pixelsort(array, compare_fn){
    this.array = array;
    this.compare = compare_fn;
    this.fn_list = {};
    this.fn = {};
    this.run = true;
    
    this.tileset = function(id, tile={col:100, row:1, size:10}){
        this.node_id = id;
        this.tile = tile;
    };
    this.setup = function(array, compare_fn){
        this.array = array;
        this.compare = compare_fn;
    };
    this.add = function(){
        for (var i = 0; i < arguments.length; i++) {
            //FIXME: check function existence
            var algo = arguments[i];
            var name = (typeof algo === 'function') ? algo.name
                                                    : algo;
//uhm?      
            //var fn = algo;
            //careful: global row and swap_history
            for(row=0; row < this.tile.row; row++){
                swap_history[row] = [];
                algo(this.array[row].slice(0), this.compare);
            }
            this.fn_list[name] = new pixelcanvas(this.node_id, this.array, swap_history, this.tile);
            this.fn_list[name].reset();
            this.fn[name] = window[name];
  }
        //this.fn_list[algo.name].start();
    };
    this.clear = function(){
        for(var key in this.fn_list){
            this.destroy(key);
        }
    };
    this.reset = function(){
        for(var key in this.fn_list){
            this.fn_list[key].reset();
        }
    };

    this.rebuild = function(){
        for(var key in this.fn_list){
            this.remove(key);
            this.add(this.fn[key]);
        }
    }
    this.remove = function(algo){
        var name = (typeof algo === 'function') ? algo.name
                                                : algo;
        this.fn_list[name].canvas.remove();
    };
    this.destroy = function(algo){
        this.remove(algo);
        delete this.fn_list[name];
    };
    this.startAll = function(){
        for(var key in this.fn_list){
            this.fn_list[key].start();
        }
    };
    this.stopAll = function(){
        for(var key in this.fn_list){
            this.fn_list[key].stop();
        }
    };
    this.play = function(){
        this.run = !this.run;
        return (this.run)?this.startAll():this.stopAll();
    };
}


if(window.location.hash){
tile.size = Number(window.location.hash.substring(1));
}



var p;

p = new pixelsort(grid(default_tile_col, default_tile_row), cmp);
p.tileset('#sandbox', tile);
p.add(insertionsort, quicksort);

p.startAll();

var chk = document.getElementById("algorithms");
var algorithms = [insertionsort, insertionsort_binary, lampsort, quicksort, quicksort_dualpivot];
algorithms.forEach((fn)=>{
let n = fn.name;
chk.innerHTML += '<input type="checkbox" id="'+n+'" name="'+n+'" value="'+n+'" /><label for="'+n+'">'+n+'</label>';
});


/*************************************************************/
//Fisher--Yates' shuffle
//nicely explained and visualized here, https://bost.ocks.org/mike/shuffle/
function shuffle(array){
    var m = array.length, rand;
    while(--m){
            rand = ~~(Math.random()*m);
            [array[m], array[rand]] = [array[rand], array[m]];
    }
}
/*************************************************************/

function swap(array,i,j){
    [array[i], array[j]] = [array[j], array[i]];
    swap_history[row].push([i,j, array[i],array[j]]);
}
/*************************************************************/

function insertionsort(array, compare_fn){
	for(var i=0;i < array.length; i++){
		for(var j=i; j>0 && compare_fn(array[j-1],array[j]); j--){
			swap(array, j, j-1)
		}
	}
return array;
}
//TODO
            //if(left){for(var j=end; j>middle;j--){swap(array, j, j-1);}}else{for(var j=start; j<middle;j++){swap(array, j, j-1);}}
function insertionsort_binary(array, compare_fn){
	var search, value, start, end, middle, now;


        //var MAX = 200;
function moveupto(i,j){if(i>=j){return;}
//console.log('move up from '+i+' to '+j)
for(; i<j;i++){swap(array, i, i+1);}

}
function movedownto(j,i){if(i>=j){return;}
//console.log('move down from '+j+' to '+i)
for(; j>i;j--){swap(array, j, j-1);}}

//console.log(""+array)
//*/
	for(var sorted = 1; sorted < array.length; sorted++){
		value = array[sorted];
//console.log('move '+value)
		start = 0;
		end = sorted-1;
        now = sorted;
		search=true;

		while(search){// && MAX-- >0){
//console.log('start '+start + ' end '+ end+' now '+now)
            middle= ~~((end+start)/2 );
//console.log('middle ('+middle+') '+array[middle])
			if(compare_fn(array[middle],value)){
//console.log('smaller')
                if(now>middle) {
//console.log('movedownto')
movedownto(now,middle);
now=middle;
end++;
} else {
moveupto(now,middle-1);
now=middle-1;
start--;
}
                
				end=middle-1;
                
				if(!compare_fn(array[middle-1], value)){//array[-1]=undefined=0
					//search=false;
				}
			}else{
//console.log('bigger')
if(now>middle) {
movedownto(now,middle+1);
now=middle+1;
start = middle+2
end++;
} else {
moveupto(now,middle);
now=middle;
start=middle;
start++;
}
   

				middle++;
				if(compare_fn(array[middle],value) || middle==sorted){
					//search=false;
				}
			}
        if(( !compare_fn( array[now-1],value) ) && ( compare_fn(array[now+1], value) || now==sorted) ) {
search=false
//console.log('found '+array[now-1]+' '+array[now]+' '+array[now+1])
}
//console.log(""+array);
		}

             
		
		//for(var j=sorted; j>moveto; j--){swap(array, j, j-1)}
	}
//*/
return array;
}


function quicksort(array, compare_fn){
	function _quicksort(array, from, to, compare_fn){
		if (to - from > 0) {
		  for (var pivot = array[to], R = from, L=from; R < to; R++) {
			if (compare_fn(pivot, array[R])){
			  swap(array, R, L);
			  L++;
			}
		  }
		  swap(array, L, to);
		  _quicksort(array, from, L - 1, compare_fn);
		  _quicksort(array, L + 1, to, compare_fn);
		}
		return array;
	}
	return _quicksort(array, 0, array.length-1, compare_fn);
}

function quicksort_dualpivot(array, compare_fn){
var queue = [0, array.length-1],
		pending = 1;
	var L, R, cur, pivot_min, pivot_maj, from, to;
	while(pending>0){
		from = queue[pending-1]; to = queue[pending];
		pivot_min = array[from]; pivot_maj = array[to];
		if(compare_fn(pivot_min, pivot_maj) ){
			[pivot_maj, pivot_min] = [pivot_min, pivot_maj];
			swap(array, from, to);
		}
		for(cur = L = from+1, R = to-1; cur <= R; cur++) {
			if( compare_fn(pivot_min, array[cur]) ){
				swap(array, cur, L);
				L++;
			}else if( compare_fn(array[cur], pivot_maj) ){
				swap(array, cur, R);
				R--; cur--;	
			}
		}
		L--; R++;
		swap(array, L,from);
		swap(array, R, to);
		queue.pop();queue.pop();
		if(L - from > 1) queue.push(from, L-1);
		if(R - L > 2) queue.push(L+1, R-1);
		if(to - R > 1) queue.push(R+1, to);
		pending = queue.length-1;
	}
return array;
}

function lampsort(array, compare_fn){
	var queue = [0, array.length-1],
		pending = 1;
	var L, R, pivot, from, to;
	var rside;
	while(pending>0){
      from = queue[pending-1];
	  to = queue[pending];
      for (pivot = array[to], R = from, L = from; R < to; R++) {
        if ( compare_fn(pivot, array[R]) ){
          swap(array, L,R);
          L++;
        }
      }
      swap(array, L,to);

		rside = queue[pending] - (L+1) >0;

		if((L-1) - queue[pending-1] >0){
			if(rside) queue.push(L+1, queue[pending]);
			queue[pending]=L-1;
		}
		else if(rside) { queue[pending-1]=L+1; }
		else{ queue.pop(); queue.pop();}	
		pending = queue.length-1;
	}
return array;
}


</script>
</body>